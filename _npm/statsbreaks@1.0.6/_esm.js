/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/statsbreaks@1.0.6/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function e(e){return null!==e&&""!==e&&"boolean"!=typeof e&&isFinite(e)}function t(e,t){return[s(e[0],t),e.slice(1,-1).map((e=>function(e,t){const s=Math.pow(10,t),n=e*s*(1+Number.EPSILON);return Math.round(n)/s}(e,t))),n(e[e.length-1],t)].flat()}function s(e,t){const s=Math.pow(10,t),n=e*s*(1+Math.sign(e)*Number.EPSILON);return Math.floor(n)/s}function n(e,t){const s=Math.pow(10,t),n=e*s*(1-Math.sign(e)*Number.EPSILON);return Math.ceil(n)/s}function r(e,t){const s=((e=e.sort(((e,t)=>e-t))).length-1)*t,n=Math.floor(s),r=s-n;return void 0!==e[n+1]?e[n]+r*(e[n+1]-e[n]):e[n]}class i extends Error{constructor(){super("Values must be superior or equal to zero"),this.name="ValuesInferiorOrEqualToZeroError"}}class l extends Error{constructor(){super("Too few values for the given number of breaks"),this.name="TooFewValuesError"}}class a extends Error{constructor(){super("Unknown classification method"),this.name="UnknownMethodError"}}class u extends Error{constructor(e){super(e||"Invalid number of classes"),this.name="InvalidNumberOfClassesError"}}class o extends Error{constructor(e){super(e||"Invalid precision"),this.name="InvalidPrecisionError"}}function h(t){if(!e(t))throw new u("The 'nb' parameter must be a number");if(t=+t,!Number.isInteger(t))throw new u("The 'nb' parameter must be an integer");if(t<2)throw new u("The 'nb' parameter must be superior or equal to 2");return t}function c(t){if(null===t)return null;if(void 0===t)return 2;if(!e(t))throw new o("The 'precision' parameter must be a number");if(t=+t,!Number.isInteger(t))throw new o("The 'precision' parameter must be an integer");if(t<0)throw new o("The 'precision' parameter must be superior or equal to 0");return t}function f(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let i=c(n.precision),a=!0===n.minmax||null==n.minmax;if(6>s.length)throw new l;let u=[r(s,0),r(s,.05),r(s,.25),r(s,.5),r(s,.75),r(s,.95),r(s,1)];return null!==i&&(u=t(u,i)),a||(u=u.slice(1,-1)),u}function m(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let i=null!=n.nb?h(n.nb):5,a=c(n.precision),u=!0===n.minmax||null==n.minmax;if(i>s.length)throw new l;let o=[];const f=1/i;for(let e=0;e<=i;e++)o.push(r(s,f*e));return o=o.sort(((e,t)=>e-t)),null!==a&&(o=t(o,a)),u||(o=o.slice(1,-1)),o}function p(t){let s=1/0;for(let n=0,r=t.length;n<r;n++)e(t[n])&&t[n]<s&&(s=t[n]);return s}function b(t){let s=-1/0;for(let n=0,r=t.length;n<r;n++)e(t[n])&&t[n]>s&&(s=t[n]);return s}function _(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=null!=n.nb?h(n.nb):5,i=c(n.precision),a=!0===n.minmax||null==n.minmax;if(r>s.length)throw new l;let u=[p(s),b(s)];const o=(u[1]-u[0])/r;let f=u[0];for(let e=0;e<r-1;e++)u.push(f+o),f+=o;return u=u.sort(((e,t)=>e-t)),null!==i&&(u=t(u,i)),a||(u=u.slice(1,-1)),u}function d(s,n={}){s=s.filter((t=>e(t))).map((e=>+e)).sort((function(e,t){return e-t}));let r=null!=n.nb?h(n.nb):5,i=c(n.precision),a=!0===n.minmax||null==n.minmax;if(r>s.length)throw new l;if(r>[...new Set(s)].length)throw new l("Too few unique values for the given number of breaks");let u=function(e,t){const s=[],n=[],r=e.length;let i,l,a,u,o,h,c,f,m,p,b,_;for(i=0;i<r;i++){const e=[],r=[],a=0===i?1:0;for(l=0;l<t;l++)e.push(a),r.push(1/0);s.push(e),n.push(r)}for(o=0,u=0;u<r;u++){for(c=f=m=0,a=0;a<=u;a++)if(_=u-a,h=e[_],m++,c+=h,f+=h*h,o=f-c*c/m,b=_-1,b>-1)for(l=1;l<t;l++)p=o+n[b][l-1],n[u][l]>=p&&(s[u][l]=_+1,n[u][l]=p);s[u][0]=1,n[u][0]=o}return{lower_class_limits:s,variance_combinations:n}}(s,r),o=function(e,t,s){const n=[];let r,i,l=e.length;for(n[s]=e[e.length-1],n[0]=e[0],r=1;r<s;r++)i=s-r+1,n[i-1]=e[t[l-1][i-1]-2],l=t[l-1][i-1]-1;return n}(s,u.lower_class_limits,r);return null!==i&&(o=t(o,i)),a||(o=o.slice(1,-1)),o}function w(t){let s=t.filter((t=>e(t))).map((e=>+e));return s.reduce(((e,t)=>+e+ +t),0)/s.length}function k(t){let s=t.filter((t=>e(t))).map((e=>+e)),n=w(s);return 1*function(t){return t.filter((t=>e(t))).map((e=>+e)).reduce(((e,t)=>+e+ +t),0)}(s.map((e=>(e-n)**2)))/(s.length-1)}function g(e){return Math.sqrt(k(e))}function x(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=e(n.k)?n.k:1,i=!1!==n.middle&&null!=n.middle,l=c(n.precision),a=!0===n.minmax||null==n.minmax;const u=p(s),o=b(s),h=w(s),f=g(s);let m=[u,o];if(1==i){let e=h+r/2*f;for(;e<o;)m.push(e),e+=f*r;for(e=h-r/2*f;e>u;)m.push(e),e-=f*r}else{m.push(h);let e=h+f*r;for(;e<o;)m.push(e),e+=f*r;for(e=h-f*r;e>p;)m.push(e),e-=f*r}return m=m.sort(((e,t)=>e-t)),null!==l&&(m=t(m,l)),a||(m=m.slice(1,-1)),m}function v(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=null!=n.nb?h(n.nb):5,a=c(n.precision),u=!0===n.minmax||null==n.minmax;if(r>s.length)throw new l;if(s.some((e=>e<=0)))throw new i;let o=new Array(r+1);const f=p(s),m=b(s),_=Math.log(m)/Math.LN10,d=Math.log(f)/Math.LN10,w=(_-d)/r;o[0]=f;for(let e=1;e<r;e++)o[e]=Math.pow(10,d+e*w);return o[r]=m,o=o.sort(((e,t)=>e-t)),null!==a&&(o=t(o,a)),u||(o=o.slice(1,-1)),o}function y(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=null!=n.nb?h(n.nb):5,i=c(n.precision),a=!0===n.minmax||null==n.minmax;if(r>s.length)throw new l;let u=[],o=0;for(let e=0;e<=r;e++)o+=e;let f=p(s),m=b(s),_=(m-f)/o;for(let e=0;e<=r;e++)u[e]=0===e?f:e===r?m:u[e-1]+e*_;return null!==i&&(u=t(u,i)),a||(u=u.slice(1,-1)),u}function M(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=null!=n.nb?h(n.nb):5,i=c(n.precision),l=!0===n.minmax||null==n.minmax,a=[p(s)];if(function e(t){const s=w(t);a.push(s);const n=t.filter((e=>e>s));for(;n.length>1&&n.length/t.length<=.4;)return e(n)}(s),r&&null!==r){r-a.length<0&&a.splice(r)}return a.push(b(s)),null!==i&&(a=t(a,i)),l||(a=a.slice(1,-1)),a}function E(e,t=!0){let s,n=Math.floor(Math.log10(e)),r=e/Math.pow(10,n);return s=t?r<1.5?1:r<3?2:r<7?5:10:r<=1?1:r<=2?2:r<=5?5:10,s*10**n}function q(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));const r=c(n.precision),i=!0===n.minmax||null==n.minmax,a=null!=n.nb?h(n.nb):5;if(a>s.length)throw new l;const u=p(s),o=b(s),f=E(o-u,!1),m=E(f/(a-1),!0);let _=function(e,t,s=1){const n=[];let r=0;for(;e<t;)n[r++]=e,e+=s;return n}(Math.floor(u/m)*m,Math.ceil(o/m)*m+.5*m,m);return null!==r&&(_=t(_,r)),i||(_=_.slice(1,-1)),_}function T(s,n={}){s=s.filter((t=>e(t))).map((e=>+e));let r=null!=n.nb?h(n.nb):4;if(!(i=r)||0===i||0!=(i&i-1))throw new u("The 'nb' parameter must be a power of 2");var i;let a=c(n.precision),o=!0===n.minmax||null==n.minmax;if(r>s.length)throw new l;let f=[],m=[p(s),b(s)],_=e=>w(s.filter((t=>t>=e[0]&&t<=e[1])));for(;f.length+1<r;){let e=[m[0],...f,m[1]].reduce(((e,t,s,n)=>(s<n.length-1&&e.push([n[s],n[s+1]]),e)),[]);f=f.concat(e.map((e=>_(e)))).sort(((e,t)=>e-t))}let d=f.sort(((e,t)=>e-t));return o&&(d=[m[0],...d,m[1]]),null!==a&&(d=t(d,a)),d}function C(e,t={}){let s;switch(t.method?t.method:"quantile"){case"q6":s=f(e,t);break;case"quantile":s=m(e,t);break;case"equal":s=_(e,t);break;case"jenks":s=d(e,t);break;case"msd":s=x(e,t);break;case"geometric":s=v(e,t);break;case"headtail":s=M(e,t);break;case"pretty":s=q(e,t);break;case"arithmetic":s=y(e,t);break;case"nestedmeans":s=T(e,t);break;default:throw new a}return s}class N{constructor(e,t){if(this.constructor===N)throw new TypeError('Abstract class "AbstractClassifier" cannot be instantiated directly.');this._values=e,this.precision=c(t),this.type=null,this.nClasses=null,this._breaks=null,this._min=null,this._max=null,this._mean=null,this._median=null,this._stddev=null,this._counts=null,this._splitValues=null}get values(){return this._values}set values(e){this._values=e,this._min=null,this._max=null,this._mean=null,this._median=null,this._stddev=null,this._counts=null,this._breaks=null,this.nClasses=null}get breaks(){return this._breaks}set breaks(e){this._breaks=e,this.nClasses=e.length-1,this._counts=null}min(){return null===this._min?(this._min=p(this._values),this._min):this._min}max(){return null===this._max?(this._max=b(this._values),this._max):this._max}mean(){return null===this._mean?(this._mean=w(this._values),this._mean):this._mean}median(){return null===this._median?(this._median=function(t){let s=t.filter((t=>e(t))).map((e=>+e)).sort(((e,t)=>e-t)),n=Math.floor(s.length/2);return s.length%2!=0?s[n]:(s[n-1]+s[n])/2}(this._values),this._median):this._median}stddev(){return null===this._stddev?(this._stddev=g(this._values),this._stddev):this._stddev}population(){return this._values.length}countByClass(){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');if(null===this._counts){const e=new Array(this.nClasses).fill(0);for(let t=0;t<this._values.length;t++){const s=this._values[t];e[this.getClass(s)]++}this._counts=e}return this._counts}splitByClass(){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');if(null===this._splitValues){const e=this._values.slice().sort(((e,t)=>e-t));this._splitValues=this._breaks.slice(1).map(((t,s)=>e.filter((e=>e<=t&&e>(0===s?-1/0:this._breaks[s])))))}return this._splitValues}getClass(e){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');for(let t=0,s=this._breaks.length;t<s;t++)if(e<=this._breaks[t+1])return t;return this.nClasses}classify(){throw new Error('Method "classify" is not implemented')}}class I extends N{constructor(e,t){super(e,t),this.type="jenks"}classify(e){return this.breaks=d(this._values,{nb:e,precision:this.precision}),this._breaks}}class V extends N{constructor(e,t){super(e,t),this.type="jenks"}classify(e){return this.breaks=m(this._values,{nb:e,precision:this.precision}),this._breaks}}class B extends N{constructor(e,t){super(e,t),this.type="equal"}classify(e){return this.breaks=_(this._values,{nb:e,precision:this.precision}),this._breaks}}class L extends N{constructor(e,t){super(e,t),this.type="geometric"}classify(e){return this.breaks=v(this._values,{nb:e,precision:this.precision}),this._breaks}}class O extends N{constructor(e,t){super(e,t),this.type="q6"}classify(){return this.breaks=f(this._values,{precision:this.precision}),this._breaks}}class A extends N{constructor(e,t,s){super(e,t),this.type="custom",s&&(this.breaks=s)}classify(e){return this.breaks=e,this._breaks}}class P extends N{constructor(e,t){super(e,t),this.type="msd"}classify(e=1,t=!0){return this.breaks=x(this._values,{precision:this.precision,middle:t,k:e}),this._breaks}}class S extends N{constructor(e,t){super(e,t),this.type="headtail"}classify(e){return this.breaks=M(this._values,{nb:e,precision:this.precision}),this._breaks}}class j extends N{constructor(e,t){super(e,t),this.type="pretty"}classify(e){return this.breaks=q(this._values,{nb:e,precision:this.precision}),this._breaks}}class F extends N{constructor(e,t){super(e,t),this.type="nested-means"}classify(e){return this.breaks=T(this._values,{nb:e,precision:this.precision}),this._breaks}}class U extends N{constructor(e,t){super(e,t),this.type="arithmetic"}classify(e){return this.breaks=y(this._values,{nb:e,precision:this.precision}),this._breaks}}export{U as ArithmeticProgressionClassifier,A as CustomBreaksClassifier,B as EqualClassifier,L as GeometricProgressionClassifier,S as HeadTailClassifier,u as InvalidNumberOfClassesError,o as InvalidPrecisionError,I as JenksClassifier,P as MsdClassifier,F as NestedMeansClassifier,j as PrettyBreaksClassifier,O as Q6Classifier,V as QuantileClassifier,l as TooFewValuesError,a as UnknownMethodError,i as ValuesInferiorOrEqualToZeroError,y as arithmeticProgression,C as breaks,_ as equal,v as geometricProgression,M as headtail,d as jenks,x as msd,T as nestedMeans,q as pretty,f as q6,m as quantile};export default null;
